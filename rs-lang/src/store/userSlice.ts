import { DataForRegistration, RegistrationResponseType, userType } from './../types/type';
import { createAsyncThunk, createSlice, Action, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from './store';
import AuthService from '../api/auth';
import { AxiosError } from 'axios';

export type userState = {
  user: userType | null;
  isSuccessRegistration: boolean;
  regErrorMessage: string;
}

const initialState: userState = {
  user: null,
  isSuccessRegistration: false,
  regErrorMessage: '',
};

// below we write asynchronism

export const registration = createAsyncThunk<void, DataForRegistration, {state: RootState}>(
  'user/registration',
  async (dataUser, {dispatch}) => {
    try {
      dispatch(setRegErrorMessage(''));
      const {status, data} = await AuthService.registration(dataUser.name, dataUser.email, dataUser.password);
      if (status === 200) {
        dispatch(setIsSuccessRegistration(true));
      }
    } catch (error) {
      dispatch(setRegErrorMessage(error.response?.data));
    }
  }
);


export const userSlice = createSlice({
  name: 'user',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setIsSuccessRegistration: (state, action: PayloadAction<boolean>) => {
      state.isSuccessRegistration = true;
    },
    setRegErrorMessage: (state, action: PayloadAction<string>) => {
      state.regErrorMessage = action.payload;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    /* builder */
  },
});

// below we export the actions
export const { setIsSuccessRegistration, setRegErrorMessage } = userSlice.actions;

export default userSlice.reducer;
