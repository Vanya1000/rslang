import { RootState } from './store';
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { WordType } from '../types/type';
import wordsAPI from '../api/words';

export type bookState = {
  words: WordType[];
  currentGroup: number;
  currentPage: number;
  isFetching: boolean;
}

const initialState: bookState = {
  words: [],
  currentGroup: 0,
  currentPage: 0,
  isFetching: false,
};

// below we write asynchronism
export const fetchWordsNoAuthAsync = createAsyncThunk<WordType[] | undefined, {group: number, page: number }, {state: RootState}>(
  'book/fetchWords',
  async ({group, page}, {dispatch, getState}) => {
    try {
      const {status, data} = await wordsAPI.getWords(group, page);
      if (status === 200) {
        return data;
      }
    } catch (error) {
      console.log(error);
    }
  }
);


export const bookSlice = createSlice({
  name: 'book',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setCurrentGroup: (state, action: PayloadAction<number>) => {
      state.currentGroup = action.payload;
    },
    setCurrentPage: (state, action: PayloadAction<number>) => {
      state.currentPage = action.payload;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchWordsNoAuthAsync.fulfilled, (state, action) => {
        state.words = action.payload!;
        state.isFetching = false;
      })
      .addCase(fetchWordsNoAuthAsync.pending, (state) => {
        state.isFetching = true;
      })
  },
});

// below we export the actions
export const { setCurrentGroup, setCurrentPage } = bookSlice.actions;

export default bookSlice.reducer;
